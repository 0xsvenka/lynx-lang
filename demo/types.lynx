Option : Type -> Type               -- PascalCase indicates a type; snake_case a term
Option =
  | some : %~A -> A -> Option A     -- `%` marks the following parameter as inferable.
                                    -- In a type context, we should write `type ~ term`
                                    -- instead of `term : type`; moreover, `%~` followed
                                    -- by `A` is syntactic sugar for `%(Type ~ A)`.
  | none : %~A -> Option A

Expr : Type -> Type                 -- An example of GADT
Expr =
  | int_expr : Int -> Expr Int
  | bool_expr : Bool -> Expr Bool
  | add_expr : Expr Int -> Expr Int -> Expr Int
  | eq_expr : %~A -> Expr A -> Expr A -> Expr Bool

len : %~A -> [|A|] -> Nat
len nil = 0
len (cons _ tail) = 1 + len tail

Vec : Nat -> Type -> Type               -- Dependent type
Vec =
  | vnil : %~A -> Vec 0 A
  | vcons : %(Nat ~ n) -> %~A -> A -> Vec n A -> Vec (Suc n) A

Person = {| name : Str, age : Nat |}    -- `{|` and `|}` construct record types

Point = (|Int, Int|)                    -- `(|` and `|)` construct tuple types

Str = [|Char|]                          -- `[|` and `|]` construct `List` types

p : Person
p = { name = "Emma", age = 35 }         -- `{` and `}` with `=` construct records

word_len : Map Str Nat
word_len = { "name": 4, "age": 3 }      -- `{` and `}` with `:` construct `Map`s

origin : Point
origin = (0, 0)                         -- `(` and `)` construct tuples
single_int : (|Int|)
single_int = (1,)                       -- Tuple with one single field, which must
                                        -- be followed by a trailing comma

greeting : Str
greeting = ['H', 'e', 'l', 'l', 'o']    -- `[` and `]` construct `List`s
println (greeting |> map f).[0]         -- Meanwhile, `.[` and `]` are the index operator
