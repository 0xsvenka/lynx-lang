Option : Type -> Type               # PascalCase indicates constructor
Option =
  | Some : %~a -> a -> Option a     # `%` marks the following parameter as inferable.
                                    # In a type context, we should write `type ~ term`
                                    # instead of `term : type`; moreover, `%~` followed
                                    # by `a` is syntactic sugar for `%(Type ~ a)`.
  | None : %~a -> Option a

Expr : Type -> Type                 # An example of GADT
Expr =
  | IntExpr : Int -> Expr Int
  | BoolExpr : Bool -> Expr Bool
  | AddExpr : Expr Int -> Expr Int -> Expr Int
  | EqExpr : %~a -> Expr a -> Expr a -> Expr Bool

len : %~a -> [|a|] -> Nat 
len Nil = 0
len (Cons _ tail) = 1 + len tail

Vec : Nat -> Type -> Type               # Dependent type
Vec =
  | VNil : %~a -> Vec 0 a
  | VCons : %(Nat ~ n) -> %~a -> a -> Vec n a -> Vec (Suc n) a

Person = {| name : Str, age : Nat |}    # `{|` and `|}` construct record types

Point = (|Int, Int|)                    # `(|` and `|)` construct tuple types

Str = [|Char|]                          # `[|` and `|]` construct `List` types

p : Person
p = { name = "Emma", age = 35 }         # `{` and `}` with `=` construct records

word_len : Map Str Nat 
word_len = { "name": 4, "age": 3 }      # `{` and `}` with `:` construct `Map`s

origin : Point
origin = (0, 0)                         # `(` and `)` construct tuples
single_int : (|Int|)
single_int = (1,)                       # Tuple with one single field, which must
                                        #   be followed by a trailing comma

greeting : Str
greeting = ['H', 'e', 'l', 'l', 'o']    # `[` and `]` construct `List`s
println (greeting |> map f).[0]         # Meanwhile, `.[` and `]` are index operators
