type Tree T = Leaf T | Node (List Tree T)

type Option T = Some T | None

type Point = Point% Int Int     # Product type with anonymous fields
origin = Point% 0 0

type Pair A B = {         # Alias for a record type
    first: A
    second: B
    
    fn new (first: A) (second: B) = { first, second }

    fn get_1st self = self.first    # The return type can be omitted and inferred
    fn get_2nd self = self.second

    fn f self (n: Int) = ()
}

p = Pair::new 1 "one"
assert_eq (type_of (Pair Int Str)::get_1st) (Pair Int Str) -> Int
assert_eq ((Pair Int Str)::f p) p.f     # Binding to the `self` param
                                        # Also, `.` and `::` have higher
                                        # precedence than function application

type Expr T =                   # GADT
    IntExpr: Int -> Expr Int
  | BoolExpr: Bool -> Expr Bool
  | AddExpr: Expr Int -> Expr Int -> Expr Int
  | EqExpr: Expr T' -> Expr T' -> Expr Bool     # T and T' are distinct types
