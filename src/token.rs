use std::fmt;

/// Position in the Lynx source file.
#[derive(Debug, Clone, Copy)]
pub struct Pos(
    /// Line number.
    pub usize,
    /// Column number. `0` indicates that we are at
    /// a line break.
    pub usize,
);

impl fmt::Display for Pos {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}:{}", self.0, self.1)
    }
}

/// A span of text, delimited by two [`Pos`]s.
#[derive(Debug)]
pub struct Span(
    /// Starting position.
    pub Pos,
    /// End position (inclusive).
    pub Pos,
);

impl fmt::Display for Span {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} - {}", self.0, self.1)
    }
}

/// Different kinds of tokens.
#[derive(Debug, Clone)]
pub enum TokenKind {

    Id(
        /// The name of the identifier.
        String,
    ),

    // TODO: Support binary operators
    /// Binary operator, special identifier declared with `infix[lr]?`. It
    /// is essentially a function with two parameters, whose application
    /// appears as `a bin_op b` instead of normal `bin_op a b`. Surrounding
    /// it with parenthese denotes the corresponding "normal" function.
    BinOp(
        /// The name of the operator.
        String,
    ),

    /// Interger literal.
    IntLit(
        /// The value of the literal.
        i64,
    ),

    /// Floating-point number literal.
    FloatLit(
        /// The value of the literal.
        f64,
    ),

    /// Character literal.
    CharLit(
        /// The value of the literal.
        char,
    ),

    /// String literal.
    StrLit(
        /// The value of the literal.
        String,
    ),

    // Keywords (alphabetic & symbolic)

    // Alphabetic keywords

    /// The keyword `case`.
    Case,
    /// The keyword `import`.
    Import,
    /// The keyword `infix`.
    Infix,
    /// The keyword `infixl`.
    Infixl,
    /// The keyword `infixr`.
    Infixr,
    /// The keyword `of`.
    Of,
    /// The keyword `_`, which is considered alphabetic and
    /// not symbolic, because symbolic identifiers/keywords cannot
    /// start with `_`, while alphabetic ones can.
    Underscore,

    // Symbolic keywords

    /// The keyword `:`.
    Colon,
    /// The keyword `::`.
    DoubleColon,
    /// The keyword `.`.
    Dot,
    /// The keyword `->`.
    Arrow,
    /// The keyword `=>`.
    FatArrow,
    /// The keyword `=`.
    Bind,
    /// The keyword `@`.
    At,
    /// The keyword `|`.
    Pipe,
    /// The keyword `%`.
    Percent,
    /// The keyword `~`.
    Tilde,
    /// The keyword `%~`.
    PercentTilde,
    /// The keyword `(` (left parenthesis).
    Lp,
    /// The keyword `)` (right parenthesis).
    Rp,
    /// The keyword `(|`.
    LpPipe,
    /// The keyword `|)`.
    PipeRp,
    /// The keyword `[` (left bracket).
    Lb,
    /// The keyword `]` (right bracket).
    Rb,
    /// The keyword `.[`.
    DotLp,
    /// The keyword `[|`.
    LbPipe,
    /// The keyword `|]`.
    PipeRb,
    /// The keyword `{` (left curly brace).
    Lc,
    /// The keyword `}` (right curly brace).
    Rc,
    /// The keyword `{|`.
    LcPipe,
    /// The keyword `|}`.
    PipeRc,
    /// The keyword `,`.
    Comma,
    /// The keyword `;` or `\n` (EOL).
    ExprEnd,
    /// The keyword `\`.
    ExprContinue,
}

/// A token generated by the [`Lexer`](crate::lexer::Lexer),
/// fed to the [`Parser`](crate::parser::Parser).
/// It is described by its [`TokenKind`] and its [`Span`]
/// in the source file.
#[derive(Debug)]
pub struct Token(pub TokenKind, pub Span);
