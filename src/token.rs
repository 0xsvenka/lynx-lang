use std::fmt;

/// Position in the Lynx source file
#[derive(Debug, Clone)]
pub struct Pos(
    /// Line number
    pub usize,
    /// Column number. `0` indicates that we are at
    /// a line break.
    pub usize,
);

impl fmt::Display for Pos {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}:{}", self.0, self.1)
    }
}

/// A span of text, delimited by two [`Pos`]s
#[derive(Debug)]
pub struct Span(
    /// Starting position
    pub Pos,
    /// End position (inclusive)
    pub Pos,
);

impl fmt::Display for Span {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} - {}", self.0, self.1)
    }
}

/// Different kinds of tokens
#[derive(Debug, Clone)]
pub enum TokenKind {

    /// Identifier, which falls into either of the two categories:
    /// alphabetic identifier, starting with an alphabetic character or `_`,
    /// possibly containing alphanumeric characters, `'`, `!` and `_`;
    /// symbolic identifier, starting with a symbolic character
    /// `~`, `` ` ``, `!`, `@`, `$`, `%`, `^`, `&`, `*`, `-`, `+`, `=`,
    /// `|`, `:`, `<`, `>`, `.`, `?`, or `/`, 
    /// possibly containing the aforementioned charaters plus `'` and `_`.
    Id(String),

    /// Binary operator, special identifier declared with `infix(l|r)?`. It
    /// is essentially a function with two parameters, whose application
    /// appears as `a bin_op b` instead of normal `bin_op a b`. Surrounding
    /// it with parenthese denotes the corresponding "normal" function.
    BinOp(String),

    /// Interger literal
    IntLit(i64),

    /// Floating-point number literal
    FloatLit(f64),

    /// Character literal
    CharLit(char),

    /// String literal
    StrLit(String),

    // Keywords

    // Alphabetic keywords
    /// The keyword `case`
    Case,
    /// The keyword `import`
    Import,
    /// The keyword `infix`
    Infix,
    /// The keyword `infixl`
    Infixl,
    /// The keyword `infixr`
    Infixr,
    /// The keyword `of`
    Of,
    /// `_`, which is considered alphabetic, not symbolic,
    /// since symbolic identifiers/keywords cannot start with `_`,
    /// while alphabetic ones can. 
    Underscore,

    // Symbolic keywords
    /// `:`
    Colon,
    /// `::`
    DoubleColon,
    /// `.`
    Dot,
    /// `->`
    Arrow,
    /// `=>`
    FatArrow,
    /// `=`
    Bind,
    /// `@`
    At,
    /// `|`
    Pipe,
    /// `%`
    Percent,
    /// `~`
    Tilde,
    /// `%~`
    PercentTilde,
    /// `(` (left parenthesis)
    Lp,
    /// `)` (right parenthesis) 
    Rp,
    /// `(|`
    LpPipe,
    /// `|)`
    PipeRp,
    /// `[` (left bracket)
    Lb,
    /// `]` (right bracket)
    Rb,
    /// `[|`
    LbPipe,
    /// `|]`
    PipeRb,
    /// `{` (left curly brace)
    Lc,
    /// `}` (right curly brace)
    Rc,
    /// `{|`
    LcPipe,
    /// `|}`
    PipeRc,
    /// `,`
    Comma,
    /// `;` or `EOL`
    ExprEnd,
    /// `\`
    ExprContinue,
}

/// A token generated by the lexer, fed to the parser
#[derive(Debug)]
pub struct Token(pub TokenKind, pub Span);
