ctor List: Type -> Type;
ctor Nil: (a: Type)? -> List a;
ctor Cons: (a: Type)? -> a -> List a -> List a

ctor (+:) = Cons

(++): (a: Type)? -> List a -> List a -> List a =
  | [] ys => ys
  | (x+:xs) ys => x +: (xs++ys)

head!: (a: Type)? -> List a -> a =
  | [] => error! "empty list"
  | (x+:_) => x

tail!: (a: Type)? -> List a -> List a =
  | [] => error! "empty list"
  | (_+:xs) => xs

init!: (a: Type)? -> List a -> List a =
  | [] => error! "empty list"
  | [_] => []
  | (x+:xs) => x +: init! xs

last!: (a: Type)? -> List a -> a =
  | [] => error! "empty list"
  | [x] => x
  | (_+:xs) => last! xs

shead: (a: Type)? -> List a -> Option a =
  | [] => None
  | (x+:_) => Some x

stail: (a: Type)? -> List a -> Option (List a) =
  | [] => None
  | (_+:xs) => Some xs

sinit: (a: Type)? -> List a -> Option (List a) =
  | [] => None
  | (x+:xs) => sinit xs |>
    | (Some ys) => Some (x+:ys)
    | None => Some []

slast: (a: Type)? -> List a -> Option a =
  | [] => None
  | [x] => Some x
  | (_+:xs) => slast xs

len: (a: Type)? -> List a -> Int =
  | [] => 0
  | (_+:xs) => 1 + len xs

has_elem: (a: Type)? -> (eq a)~ -> a -> List a -> Bool =
  | _ [] => False
  | x (x'+:xs) =>
    if x == x' then True
    else has_elem x xs

zip: (a: Type)? -> (b: Type)? -> List a -> List b -> List (a*b) =
  | [] _
  | _ [] => []
  | (x+:xs) (y+:ys) => (x, y) +: zip xs ys

zip_with:
    (a: Type)? -> (b: Type)? -> (c: Type)?
    -> (a -> b -> c) -> List a -> List b -> List c =
  | _ [] _
  | _ _ [] => []
  | f (x+:xs) (y+:ys) => f x y +: zip_with f xs ys

foldl: (a: Type)? -> (b: Type)? -> (b -> a -> b) -> b -> List a -> b =
  | _ z [] => z
  | f z (x+:xs) => foldl f (f z x) xs

foldr: (a: Type)? -> (b: Type)? -> (a -> b -> b) -> b -> List a -> b =
  | _ z [] => z
  | f z (x+:xs) => f x (foldr f z xs)

scanl: (a: Type)? -> (b: Type)? -> (b -> a -> b) -> b -> List a -> =
  | _ z [] => [z]
  | f z (x+:xs) => z +: scanl f (f z x) xs

scanr: (a: Type)? -> (b: Type)? -> (a -> b -> b) -> b -> List a -> List b =
  | _ z [] => [z]
  | f z (x+:xs) => do (
      ys = scanr f z xs;
      f x (head! ys) +: ys
    )

map: (a: Type)? -> (b: Type)? -> (a -> b) -> List a -> List b =
  | _ [] => []
  | f (x+:xs) => f x +: map f xs

flat_map: (a: Type)? -> (b: Type)? -> (a -> List b) -> List a -> List b =
  | f => foldr ((++) * f) []

filter: (a: Type)? -> (a -> Bool) -> List a -> List a =
  | _ [] => []
  | p (x+:xs) =>
    if p x then x +: filter p xs
    else filter p xs
