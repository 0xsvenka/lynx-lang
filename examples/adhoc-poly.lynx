trait Mul(A, B) =
  Result: Type;
  mul: A -> B -> Result
end

impl Mul(Int, Int) =
  Result = Int;
  mul = __builtin_mul_int
end

Type~A? -> Type~B? -> Type~C? ->
impl Mul(B -> C, A -> B) =
  Result = Int;
  fn mul(f, g) = x => f(g(x))
end

fn (*)(
  A: Type?, B: Type?, m: Mul(A, B)%, a: A, b: B
): m.Result =
  m.mul(a, b)
end

trait Eq(A) =
  (==): A -> A -> Bool;
  (!=): A -> A -> Bool
end

impl Eq(Int) =
  (==) = __builtin_eq_int;
  (!=) = not * (==)
end

data Complex(A) =
  complex(A: Type?, _: A, _: A)
end

Type~A? -> Eq(A)% -> 
impl Eq(Complex(A)) =
  fn (==)(complex(x1, y1), complex(x2, y2)) =
    x1 == x2 && y1 == y2
  end

  (!=) = not * (==)
end
