trait Mul (A: Type) (B: Type) {
    Result: Type;
    mul: A -> B -> Result
}

impl Mul Int Int {
    Result = Int;
    mul = __builtin_mul_int
}

for A B C impl Mul (B -> C) (A -> B) {
    Result = A -> C;
    fn mul f g { x => f (g x) }
}

fn (*) @A @B @(m: Mul A B) (a: A) (b: B) : m.Result {
    m.mul a b
}

trait Eq (A: Type) {
    (==): A -> A -> Bool;
    (!=): A -> A -> Bool
}

impl Eq Int {
    (==) = __builtin_eq_int;
    (!=) = x => not * (==) x
}

data Complex (A: Type) {
    complex @A (_: A) (_: A)
}

for A (_: Eq A) impl Eq (Complex A) {
    fn (==) (complex x1 y1) (complex x2 y2) {
        x1 == x2 && y1 == y2
    };
    (!=) = x => not * (==) x
}
