Mul: Type -> Type -> Type' =
  | A B =>
  {
    R: Type,
    mul: A -> B -> R
  }

int_int_mul: Mul Int Int =
  {
    R = Int,
    mul = __builtin_mul_int
  }

fn_fn_mul:
    (A: Type)? -> (B: Type)? -> (C: Type)? -> Mul (B -> C) (A -> B) =
  {
    R = A -> C,
    mul = | f g x => f (g x)
  }

(*): (A: Type)? -> (B: Type)? -> (m: Mul A B)~ -> A -> B -> m.R =
  | m~ => m.mul

Eq: Type -> Type =
  | A =>
  {
    (==): A -> A -> Bool,
    (!=): A -> A -> Bool
  }

eq_default:
    (A: Type)? -> (A -> A -> Bool) -> (A -> A -> Bool) =
  | eq =>
  {
    (!=) = | x y => not (eq x y)
  }

int_eq: Eq Int =
  {
    (==) = __builtin_eq_int,
    (eq_default (==))...
  }

ctor Complex: Type -> Type;
ctor complex: (A: Type)? -> A -> A -> Complex A

eq_complex: (A: Type)? -> (Eq A)~ -> Eq (Complex A) =
  {
    (==) =
      | (complex x1 y1) (complex x2 y2) =>
        x1 == x2 && y1 == y2,
    (eq_default (==))...
  }
