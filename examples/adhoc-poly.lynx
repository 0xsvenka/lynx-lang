mul: Type -> Type -> Type' =
  | a b =>
  {
    r: Type,
    mul: a -> b -> r
  }

int_int_mul: mul Int Int =
  {
    r = Int,
    mul = __builtin_mul_int
  }

fn_fn_mul:
    (a: Type)? -> (b: Type)? -> (c: Type)? -> mul (b -> c) (a -> b) =
  {
    r = a -> c,
    mul = | f g x => f (g x)
  }

(*): (a: Type)? -> (b: Type)? -> (m: mul a b)~ -> a -> b -> m.r
  = m.mul

eq: Type -> Type =
  | a =>
  {
    (==): a -> a -> Bool,
    (!=): a -> a -> Bool
  }

eq_default:
    (a: Type)? -> (a -> a -> Bool) -> (a -> a -> Bool) =
  | eq =>
  {
    (!=) = | x y => not (eq x y)
  }

int_eq: eq Int =
  {
    (==) = __builtin_eq_int,
    (eq_default (==))...  -- TODO
  }

ctor Complex: Type -> Type = | (a: Type) => a * a

eq_complex: (a: Type)? -> (eq a)~ -> eq (Complex a) =
  | e~ =>
  {
    (==) =
      | (a1, b1) (a2, b2) =>
        a1 == a2 && b1 == b2,
    (eq_default (==))...
  }
