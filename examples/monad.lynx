trait Functor (F: Type -> Type) {
    fmap: @A -> @B -> (A -> B) -> F A -> F B
}

trait Applicative (F: Type -> Type) {
    pure: @A -> A -> F A;
    (<*>): @A -> @B -> F (A->B) -> F A -> F B
}

trait Monad (M: Type -> Type) {
    return: @A -> A -> M A;
    (>>=): @A -> @B -> M A -> (A -> M B) -> M B
}

for F, (a: Applicative F) impl Functor F {
    fmap = a.(<*>) * a.pure
}

for M, (m: Monad M) impl Applicative M {
    pure = m.return;
    fn (<*>) mf ma {
        mf >>= (f =>
            ma >>= (a =>
                m.return (f a)))
    }
}
