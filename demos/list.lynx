data List : Type -> Type
  | nil : %~A -> List A
  | cons : %~A -> A -> List A -> List A

-- TODO:
-- List literals like `[]` are builtin,
-- but we should be able to define `(+:)`
-- and make it a constructor.

(++) : %~A -> [|A|] -> [|A|] -> [|A|] =
  | [], ys => ys
  | x+:xs, ys => x +: (xs++ys)

head! : %~A -> [|A|] -> A =
  | [] => error! "empty list"
  | x+:_ => x

tail! : %~A -> [|A|] -> [|A|] =
  | [] => error! "empty list"
  | _+:xs => xs

init! : %~A -> [|A|] -> [|A|] =
  | [] => error! "empty list"
  | x+:[] => []
  | x+:xs => x +: init! xs

last! : %~A -> [|A|] -> A =
  | [] => error! "empty list"
  | [x] => x
  | _+:xs => last! xs

-- Safer versions of `head`, `tail`, `init` and `last`:
shead : %~A -> [|A|] -> Option A =
  | [] => none
  | x+:_ => some x

stail : %~A -> [|A|] -> Option [|A|] =
  | [] => none
  | _+:xs => some xs

sinit : %~A -> [|A|] -> Option [|A|] =
  | [] => none
  | x+:xs => sinit xs |>
    | some ys => some (x+:ys)
    | none => some []

slast : %~A -> [|A|] -> Option A =
  | [] => none
  | [x] => some x
  | _+:xs => slast xs

len : %~A -> [|A|] -> Nat =
  | [] => 0
  | _+:xs => 1 + len xs

has_elem : %~A -> #(Eq A) -> A -> [|A|] -> Bool =
  | _, [] => false
  | e, e+:xs => true
  | e, _+:xs => has_elem e xs

zip : %~A -> %~B -> [|A|] -> [|B|] -> List (|A, B|) =
  | [], _ | _, [] => []
  | x+:xs, y+:ys => (x, y) +: zip xs ys

zip_with : %~A -> %~B -> %~C
    -> (A -> B -> C) -> [|A|] -> [|B|] -> [|C|] =
  | _, [], _ => []
  | _, _, [] => []
  | f, x+:xs, y+:ys => f x y +: zip_with f xs ys

foldl : %~A -> %~B -> (B -> A -> B) -> B -> [|A|] -> B =
  | _, z, [] => z
  | f, z, x+:xs => foldl f (f z x) xs

foldr : %~A -> %~B -> (A -> B -> B) -> B -> [|A|] -> B =
  | _, z, [] => z
  | f, z, x+:xs => f x (foldr f z xs)

scanl : %~A -> %~B -> (B -> A -> B) -> B -> [|A|] -> [|B|] =
  | _, z, [] => [z]
  | f, z, x+:xs => z +: scanl f (f z x) xs

scanr : %~A -> %~B -> (A -> B -> B) -> B -> [|A|] -> [|B|] =
  | _, z, [] => [z]
  | f, z, x+:xs => do (
    ys = scanr f z xs;
    f x (head! ys) +: ys 
    )

map : %~A -> %~B -> (A -> B) -> [|A|] -> [|B|] =
  | _, [] => []
  | f, x+:xs => f x +: map f xs

flat_map : %~A -> %~B -> (A -> [|B|]) -> [|A|] -> [|B|] =
  | f => foldr ((++) * f) []

filter : %~A -> (A -> Bool) -> [|A|] -> [|A|] =
  | _, [] => []
  | p, x+:xs =>
    if p x then
      x +: filter p xs
    else
      filter p xs
