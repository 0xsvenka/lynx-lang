open Multiply : ~LHS -> ~RHS ->
  {|
    Result : Type  -- The `,` can be omitted if a `\n` follows
    mul : LHS -> RHS -> Result  -- Sigma type here!
  |}

-- Possibly in another module
Multiply Int Int =
  {
    Result = Int
    mul = __builtin_mul_int
  }

Multiply ($B -> $C) ($A -> $B) =
  {
    Result = A -> C
    mul f g = x ~> f (g x)
  }

(*) : %~LHS -> %~RHS -> LHS -> RHS -> m.Result
    where m = Multiply LHS RHS
(*) = m.mul

-- Another example

open Eq : ~A ->
  {
    ::(==) : A -> A -> Bool  -- `::` prefix indicates global namespace 
    ::(!=) : A -> A -> Bool
  }

Eq _ =
  {
    (==) = ?  -- A hole
    (!=) = not * (==)  -- A default implementation;
                       -- `*` for function composition
  }

Eq Complex A = -- TODO!
