Multiply : Type -> Type -> Type'
Multiply A B =
  {|
    R : Type
    mul : A -> B -> R
  |}

impl multiply_int : Multiply Int Int
multiply_int =
  {
    R = Int
    mul = __builtin_mul_int
  }

impl composition : %~A -> %~B -> %~C ->
    Multiply (B -> C) (A -> B)
composition =
  {
    R = A -> C
    mul f g = \x -> f (g x)
  }

(*) : %~A -> %~B -> with((Multiply A B)~m) ->
    A -> B -> m.R
(*) = m.mul


Functor : (Type -> Type) -> Type'
Functor F =
  {|
    map : %~A -> %~B
        -> (A -> B) -> F A -> F B 
  |}

impl functor_list : Functor List
functor_list =
  {
    map = List::map
  }


Eq : Type -> Type
Eq A =
  {|
    (==) : A -> A -> Bool
    (!=) : A -> A -> Bool
  |}

eq_default : %~A ->
    (A -> A -> Bool) -> (A -> A -> Bool)
eq_default eq =
  {
    (!=) x y = not (eq x y)
  }

impl eq_int : Eq Int
eq_int =
  {
    (==) = __builtin_eq_int
    (eq_default (==))...
  }

Complex : Type -> Type
Complex =
  | complex : A -> A -> Complex A

impl eq_complex : %~A -> with(Eq A) -> Eq (Complex A)
eq_complex with(e) =
  {
    (==) (complex a1 b1) (complex a2 b2) =
        e.(==) a1 a2 && e.(==) b1 b2
    (eq_default (==))...
  }
