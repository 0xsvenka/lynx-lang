Multiply : Type -> Type -> Type' =
  | A B =>
  {|
    R : Type,
    mul : A -> B -> R
  |}

multiply_int : Multiply Int Int =
  {
    R = Int,
    mul = __builtin_mul_int
  }

composition : %~A -> %~B -> %~C
  -> Multiply (B -> C) (A -> B) =
  {
    R = A -> C
    mul = |f, g, x => f (g x)
  }

(*) : %~A -> %~B -> #((Multiply A B)~m)
  -> A -> B -> m.R = m.mul


Functor : (Type -> Type) -> Type' =
  | F =>
  {|
    fmap : %~A -> %~B
      -> (A -> B) -> F A -> F B 
  |}

functor_list : Functor List =
  {
    fmap = List::map
  }


Eq : Type -> Type =
  | A =>
  {|
    (==) : A -> A -> Bool
    (!=) : A -> A -> Bool
  |}

eq_default : %~A
  -> (A -> A -> Bool) -> (A -> A -> Bool) =
  | eq =>
  {
    (!=) x y = not (eq x y)
  }

eq_int : Eq Int =
  {
    (==) = __builtin_eq_int
    (eq_default (==))...
  }

data Complex : Type -> Type
  | complex : A -> A -> Complex A

eq_complex : %~A -> #(Eq A) -> Eq (Complex A) =
  | #e =>
  {
    (==) (complex a1 b1) (complex a2 b2) =
        e.(==) a1 a2 && e.(==) b1 b2
    (eq_default (==))...
  }
